//
//  SlikeAssetLoaderDelegate.m

#define globalSplitStringSecure     @"fmwrk4zonihq2udbx6ysa3e15pjlctgvuxmcrs4j2la3fvdy1nzwghei5b6qkptozhwyi2msprqgkvcbjn5o1tdexaf3ul64ofebrw6nlkxz2qmi3syjg14huadt5pvcfizapc5qx6s2g3y1rdkumhe4jtnbwvloqt324zhrmcpnewxvldayigs1jbokf65ugeinv4afsbzylhd2r36qju1xcko5pmtwyoqwg24vetnxfc1ijsma3up56lkdrbzhqwajrhfkpsteo3z2xycm6dngvu1l4i5b3u14h6csbinlo5fdetaxvpqzwyjkrgm2u5xbqg1awtm62ij4dsrfplkvnz3yechot2jxkw3qnur6deabs1c5pzfymo4vghilvxq2odmyrt3jh15l6su4aezwibncpfkghyeav2cig5jr3xolbkmtwsnu1d46qfzpjf26swxomvri13etdgu4yph5qbzacknlcntr5yduqbls4fxep13zohvmaiwkj2g6e23rivlzgwkomhycutdajb4xnp5fqs16gv4x5uawh1mdfyplciqtr3nb6zj2oeskzxphercb5idmufv2n3ytsg4lkajwo16q5dxcpl2fbujasvtwze1rgm36hoy4nqik4coqdthn2iwp6fal1jbygexrvm3uzsk5wcd5joeqmpbyk1uriagzftlx24hvs3n6okt3bhfuqi4nwx2yjmzd1asrplveg6c5qpgliv1btcnkzd5eoh24suxarmyj6wf3wage6smr51uzifyknvjlp2hodbqx4c3t5bqy1rne4fkgjzdvtopsc2x6awhu3ilmup1m5bsihd3kvwygor2zcxe4fa6tqnljo2ui61ehsl5crpbtqvf4wgyamxjkz3nd1eoxhrznmwua6qv4fpsyl3jbg2k5tdicwg3boymudrh2xqcfpi1vz4jnaklt65eshdpbti4oyal2zr5ve6fxk3nwcgmsqju11nlf4vkpgwutd6jrocb3qhexysai5zm2ywpju3calebz1hdfoqivm64ktrx5gn2sxq5yvzgdh6ncpm1bis43rowuetjfkla2gailh6kzsup34rbjqtfc12mvoynxdw5ehm5q2spwx6ckjno3da14zyeiugtlbvfrq1jumkalp24yscrdxgebn6vzit5f3howwtefzpgjsqcvlkih4d3amxy2ruo615bnnxeogw6fh25tk1pyc4virbldmu3asjqzkpq25xelusdi3myjzctw4r1bhnf6goavqklefjt2xzw4d1gu6b3rmanyi5hspcvozmtuj1rcvligq65nb3s4dopahky2efxwjzegryi4wsm21kuopdlt3na56hxqcfbvmw1fxbdj3nlk4ya2vq6rheicuz5potsgmuc612dxbznt5foieyrgap4klqh3vwjsm3pt16jygna2bhdezwci5vu4srofqxklfsumto5zid2al3njbkhwypvq1xge4r6c3l4qky1bmntxpd2cs5wgeifrjzah6vousmkfxcq6hvdbw45jpnytzieao2u13glr2i6cxobhnupyqsr5kzawl4dtegm1fvj3gdm1sfatp3hi42bjvowzckq5ruy6lxnedoir4qpfemhza6l1x2tbvg5snyucj3kwunk6qf1a53ybs2hriepjz4gwcdxvltomlrvqcpodgahmyjbzuwnf25tes146kx3irtlkcpxjbgyeso6iz4wqhmf12dv5aun3posrbm6fetdu12hkjyzwglxn4vacq53i4h2v1zqylcok3xmuns6rdtiw5ebpjfgac5o3qzlpvwkgu6xtjder4fmh1bs2inyabonvpld6a5isw4eq2fxryjkhzcm3gu1tt562ezahq3knoc4isvlxuyjmwbpr1gfdpibqx3n5mt24vdlrcuhyws6fgao1jkezonvxep1tyamdfjc54grzkswuqhi32b6lv1dtjxmrf2hs6pkzlbicuwyg5noaqe43uey3bnaimdswf2ozxrpgkc5vjhl64t1q5cd1rxo3msgtknuqvwjie462lbzafyph6tlb5uagwirhzvsc3njyk4mopedqx2f1ga5tz6nkj32ilcrvehmfqospb4y1duxwqr5dlpmucwtaivjyognkxhb1f34esz26gqno1puc34ysk6rtafdxlzejmw5hvb2iqernjwkgluf4dz3b1y2caoi6v5tmxspharmkhfu21ij3dvwnq6bsgetxy5o4pczl36rpxij5cf2a1hqbmoynugwtvd4elzskwi41qvsmpkaneothu6ydr23cbgxl5zfjbws3hxlqk1mn6jdpuvaiyf5geoct24zrnl3i6rge1kt4ypqaujhvfw5b2mcsoxdz236tih5lq4baduerpfgosxjn1kycvwzmsbrygopcwi1kevj6nlxz345mhdq2uatf5oqcp3tfwmyr2skj6lg4ebaz1duinvxhlza3gq4hwbucxrtpf1o6i5sekjdmynv21bm3npufjasrh52l4qycoegxzvk6itdw4qsdvlnc3pfkoi6jmeuwr2a1zbhy5xtgsdyl4mjfp6ez1irvngwua53qbtxok2chdyagksp2ul35wthzxcjnrfoq4bmv1e6iscnqjo5ai3bwe6fl4pvhd2grmuktzxy1ukpdhozlntrqixgys2wjbavc163emf454hpngq5ivlets2cxk3bu1ayozjrfwmd6srbpfa54udnwx1j3kte2glymqho6izvcjkydxis6nbz1uvp3ah2tcgm4folerqw5xu6zogdc1sbh5na3twlpk4f2mvryjeiqvs51kthxgf263mrbqzinaujwdec4yoplcahbvone61g24yjkrsipq5t3ufdmzlxw2b643mwi5pvlfnujq1gtzecdskyhaxrooeyubfkazcwimxls5nvjrpd4h23gt6q1b3vn1cqzmkdpaxfyut4joig56ls2hwerdbjiwth3nrv6lgaqpofsm2ux1k4ze5yc3kqhmbysjxli4ncu2of1pwzatd5rv6egfq3ltgybzn6hekxmwcrpo2avsd15uj4igzpwd3acej4rnso5itulm2vb16yhkfxqxu16r2gfyvkejhqpodinctwalbzs54m3rq13pcfn4meixuv5ldbtjsohgkyazw62"

#import "SlikeAssetLoaderDelegate.h"
#import "SlikeNetworkManager.h"
#import "SlikeSharedDataCache.h"
#import "SlikeBitratesModel.h"
#import "SlikeNetworkInterface.h"


NSString * const AVERAGE_BANDWIDTH = @"AVERAGE-BANDWIDTH";
NSString * const BANDWIDTH = @"BANDWIDTH";
NSString * const CODECS = @"CODECS";
NSString * const RESOLUTION = @"RESOLUTION";
NSString * const RESBASED_DISPLAY = @"ResBasedDisplay";
NSString * const COMPARATOR = @"comparator";
NSString * const SLKURL = @"url";
NSString * const TAG_PLAYLIST = @"#EXTM3U";
NSString * const TAG_STREAM = @"#EXT-X-STREAM-INF:";
static NSString  *TAG_KEYSPL = @"#EXT-X-KEY";
static NSString  *strXSTREAMINFSPL = @"#EXT-X-STREAM-INF:";

@interface SlikeAssetLoaderDelegate() {
}

@end

@implementation SlikeAssetLoaderDelegate {
    
}

- (id)init{
    if (self = [super init]) {
        
        self.baseURI = @"";
        self.cacheDir = [SlikeAssetLoaderDelegate cacheDirectory];
        self.pendingRequests = [NSMutableArray array];
        self.serialQueueAssetLoader = dispatch_queue_create("com.slikeSPL.queueAssetLoader", DISPATCH_QUEUE_SERIAL);
        self.isDecoded = -1;
            _splitArray =  [self splitArrayFromGlobalString:globalSplitStringSecure];
        
    }
    return self;
}

#pragma mark - NSURLConnection delegate
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response{
    self.movieData = [NSMutableData data];
    self.response = (NSHTTPURLResponse *)response;
    [self processPendingRequests];
}
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data{
    [self.movieData appendData:data];
    [self processPendingRequests];
}
- (void)connectionDidFinishLoading:(NSURLConnection *)connection{
    [self processPendingRequests];
    NSString *fileName = [NSURL URLWithString:self.fileUrl].absoluteString.lastPathComponent;
    NSString *cachedFilePath = [[NSString alloc] initWithFormat:@"%@/%@",self.cacheDir,[fileName componentsSeparatedByString:@"?"].firstObject];
    BOOL writen = [self.movieData writeToFile:cachedFilePath atomically:YES];
    if(!writen){
        NSLog(@"Error");
    }
}
#pragma mark - AVURLAsset resource loading
- (void)processPendingRequests{
    NSMutableArray *requestsCompleted = [NSMutableArray array];
    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests){
        [self fillInContentInformation:loadingRequest.contentInformationRequest];
        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest];
        if (didRespondCompletely){
            [requestsCompleted addObject:loadingRequest];
            [loadingRequest finishLoading];
        }
    }
    [self.pendingRequests removeObjectsInArray:requestsCompleted];
}

- (void)fillInContentInformation:(AVAssetResourceLoadingContentInformationRequest *)contentInformationRequest{
    if (contentInformationRequest == nil || self.response == nil){
        return;
    }
    NSString *mimeType = [self.response MIMEType];
    CFStringRef contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge CFStringRef)(mimeType), NULL);
    contentInformationRequest.byteRangeAccessSupported = YES;
    contentInformationRequest.contentType = CFBridgingRelease(contentType);
    contentInformationRequest.contentLength = [self.response expectedContentLength];
}

- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest{
    long long startOffset = dataRequest.requestedOffset;
    if (dataRequest.currentOffset != 0){
        startOffset = dataRequest.currentOffset;
    }
    // Don't have any data at all for this request
    if (self.movieData.length < startOffset){
        return NO;
    }
    // This is the total data we have from startOffset to whatever has been downloaded so far
    NSUInteger unreadBytes = self.movieData.length - (NSUInteger)startOffset;
    // Respond with whatever is available if we can't satisfy the request fully yet
    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);
    [dataRequest respondWithData:[self.movieData subdataWithRange:NSMakeRange((NSUInteger)startOffset, numberOfBytesToRespondWith)]];
    long long endOffset = startOffset + dataRequest.requestedLength;
    BOOL didRespondFully = self.movieData.length >= endOffset;
    return didRespondFully;
}

+ (NSString*) preViewFoundInCacheDirectory:(NSString*) url{
    NSString *fileName = [NSURL URLWithString:url].absoluteString.lastPathComponent;
    NSString *cachedFilePath = [[NSString alloc] initWithFormat:@"%@/%@",[SlikeAssetLoaderDelegate cacheDirectory],[fileName componentsSeparatedByString:@"?"].firstObject];
    if([[NSFileManager defaultManager] fileExistsAtPath:cachedFilePath]){
        return cachedFilePath;
    }
    else{
        return nil;
    }
}
+ (NSString *)cacheDirectory{
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
    NSString *cacheDir = [paths objectAtIndex:0];
    NSString *videoCacheDir = [NSString stringWithFormat:@"%@/%@",cacheDir,@"Previews"];
    
    BOOL isDir = NO;
    NSError *error;
    if (! [[NSFileManager defaultManager] fileExistsAtPath:videoCacheDir isDirectory:&isDir] && isDir == NO) {
        [[NSFileManager defaultManager] createDirectoryAtPath:videoCacheDir withIntermediateDirectories:YES attributes:nil error:&error];
    }
    
    return videoCacheDir;
}


//Slike Task-
#pragma resource handling----
- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest {
    NSString *url = loadingRequest.request.URL.absoluteString;
    if([url containsString:@".ts"]) {
        return [self handleSegmentsRequest:loadingRequest];
    } else if(loadingRequest.dataRequest) {
        return [self handlePlaylistRequest:loadingRequest];
    }
    return YES;
}

- (BOOL)handlePlaylistRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:loadingRequest.request.URL resolvingAgainstBaseURL:NO];
    
    if([urlComponents.scheme isEqualToString:@"123"]) {
        urlComponents.scheme = @"https";
        
    } else {
        urlComponents.scheme = @"http";
    }
    
    BOOL isAvailable = [[SlikeSharedDataCache sharedCacheManager] isBitratesAvailableForStream];
    NSMutableString *currentURL = [[SlikeSharedDataCache sharedCacheManager]currentStreamBitrateURL];
    
    if (isAvailable && currentURL) {
        NSData *charlieSendData = [currentURL dataUsingEncoding:NSUTF8StringEncoding];
        [loadingRequest.dataRequest respondWithData:charlieSendData];
        [loadingRequest finishLoading];
        return TRUE;
    }
    
    if(!self.isEncrypted)
    {
        SlikeDLog(@"%lu",(unsigned long)[SlikeSharedDataCache sharedCacheManager].currentStreamBitrate);
        
    NSError *error = nil;
    SPLM3U8PlaylistModel *model = [[SPLM3U8PlaylistModel alloc] initWithURL: [urlComponents URL] error:&error];
    if(self.baseURI && [self.baseURI isEqualToString:@""])
    {
        [self processMasterPlayListData: model.masterPlaylist.originalText];
    }
    __block NSString * actualM3U8 = model.mainMediaPl.originalText;
    NSCharacterSet *newlineCharSet = [NSCharacterSet newlineCharacterSet];
    NSArray *lines = [actualM3U8 componentsSeparatedByCharactersInSet:newlineCharSet];
    [lines enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSString *lineString = (NSString *)obj;
        
        if ([lineString hasPrefix:TAG_KEYSPL] && [lineString containsString:@"keys.slike.in"]) {
            self.isEncrypted = YES;
            actualM3U8 = [actualM3U8 stringByReplacingOccurrencesOfString:lineString
                                                               withString:@""];
            
        }
    }];
    }
    
    [SlikeSharedDataCache sharedCacheManager].isEncrypted = self.isEncrypted;
    if(self.isEncrypted)
    {
        [self getActualM3U8:[urlComponents URL] withCompletion:^(NSString *result)
         {
             
             NSData *charlieSendData = [result dataUsingEncoding:NSUTF8StringEncoding];
             [loadingRequest.dataRequest respondWithData:charlieSendData];
             [loadingRequest finishLoading];
             return YES;
         }];
    }else
    {
        [[SlikeNetworkInterface sharedNetworkInteface] getHLSStreamDataString:[urlComponents string] withCompletionBlock:^BOOL(NSArray *bitratesArray, NSString *responseString, NSError *error) {
            if (error) {
                return NO;
            }
            [self parsePlaylistString:responseString baseUrl:[urlComponents string] loading:loadingRequest];
            return YES;
        }];
    }
    return YES;
}


- (BOOL)parsePlaylistString:(NSString *)hlsContent baseUrl:(NSString *)baseUrl loading:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    //No Bitrates available . So we need to create
    __block NSMutableString * lowBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    __block NSMutableString * mediumBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    __block NSMutableString * highBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    __block NSMutableString * autoBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    
    NSMutableArray *bitratesModelArray = [[NSMutableArray alloc]init];
    
    [lowBitrate appendString:@"\n"];
    [mediumBitrate appendString:@"\n"];
    [highBitrate appendString:@"\n"];
    [autoBitrate appendString:@"\n"];
    
    NSArray *lines = [hlsContent componentsSeparatedByString:@"\n"];
    NSInteger lineIndex = 0;
    
    while (lineIndex < [lines count]) {
        
        NSString *line = [lines objectAtIndex:lineIndex];
        if ([line rangeOfString:TAG_STREAM].location == 0) {
            
            NSArray *params = [[line substringFromIndex:[TAG_STREAM length]] componentsSeparatedByString:@","];
            
            NSString *keyValueString = nil;
            long long bitrate = 0;
            long long height = 0;
            
            [autoBitrate appendString:[lines objectAtIndex:lineIndex]];
            [autoBitrate appendString:@"\n"];
            NSInteger autoIndex = lineIndex;
            ++autoIndex;
            NSString *autoStreamURL = [self streamRelativeUrl:[lines objectAtIndex:autoIndex] withBase:baseUrl];
            [autoBitrate appendFormat:@"%@\n", autoStreamURL];
            for (NSInteger itemIndex = 0; itemIndex < [params count]; itemIndex++) {
                
                keyValueString = [params objectAtIndex:itemIndex];
                if ([keyValueString rangeOfString:@"BANDWIDTH"].location != NSNotFound) {
                    bitrate = [[[keyValueString componentsSeparatedByString:@"="] objectAtIndex:1] longLongValue];
                }
                else if ([keyValueString rangeOfString:@"RESOLUTION"].location != NSNotFound) {
                    NSString *heightSting = [[keyValueString componentsSeparatedByString:@"="] objectAtIndex:1];
                    height = [[[heightSting componentsSeparatedByString:@"x"] objectAtIndex:1] longLongValue];
                }
            }
            
            bitrate = bitrate/1000;
            if (height < 360 || bitrate < 450) {
                
                [lowBitrate appendFormat:@"%@\n", [lines objectAtIndex:lineIndex]];
                lineIndex++;
                NSString *streamURL = [self streamRelativeUrl:[lines objectAtIndex:lineIndex] withBase:baseUrl];
                [lowBitrate appendFormat:@"%@\n", streamURL];
                
            } else if ((height <= 480 && height >= 360) ||
                       (bitrate <= 800 && bitrate >= 450)) {
                
                [mediumBitrate appendFormat:@"%@\n", [lines objectAtIndex:lineIndex]];
                lineIndex++;
                NSString *streamURL = [self streamRelativeUrl:[lines objectAtIndex:lineIndex] withBase:baseUrl];
                [mediumBitrate appendFormat:@"%@\n", streamURL];
                
            }
            else if (height > 480 || bitrate > 800) {
                [highBitrate appendFormat:@"%@\n", [lines objectAtIndex:lineIndex]];
                lineIndex++;
                NSString *streamURL = [self streamRelativeUrl:[lines objectAtIndex:lineIndex] withBase:baseUrl];
                [highBitrate appendFormat:@"%@\n", streamURL];
            }
        }
        lineIndex++;
    }
    
    NSInteger validationCons = 5;
    
    if ([autoBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* autoBitrateModel =  [[SlikeBitratesModel alloc]init];
        autoBitrateModel.bitrateName = @"Auto";
        autoBitrateModel.bitrateUrl = autoBitrate;
        autoBitrateModel.isValid = YES;
        autoBitrateModel.bitrateType = SlikeMediaBitrateAuto;
        [bitratesModelArray addObject:autoBitrateModel];
    }
    
    if ([lowBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* lowBitrateModel =  [[SlikeBitratesModel alloc]init];
        lowBitrateModel.bitrateName = @"Low";
        lowBitrateModel.bitrateUrl = lowBitrate;
        lowBitrateModel.isValid = YES;
        lowBitrateModel.bitrateType = SlikeMediaBitrateLow;
        [bitratesModelArray addObject:lowBitrateModel];
    }
    
    if ([mediumBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* mediumBitrateModel =  [[SlikeBitratesModel alloc]init];
        mediumBitrateModel.bitrateName = @"Medium";
        mediumBitrateModel.bitrateUrl = mediumBitrate;
        mediumBitrateModel.isValid = YES;
        mediumBitrateModel.bitrateType = SlikeMediaBitrateMedium;
        [bitratesModelArray addObject:mediumBitrateModel];
    }
    
    if ([highBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* highBitrateModel =  [[SlikeBitratesModel alloc]init];
        highBitrateModel.bitrateName = @"High";
        highBitrateModel.bitrateUrl = highBitrate;
        highBitrateModel.isValid = YES;
        highBitrateModel.bitrateType = SlikeMediaBitrateHigh;
        [bitratesModelArray addObject:highBitrateModel];
    }
    
    [[SlikeSharedDataCache sharedCacheManager]cacheBitratesModel:bitratesModelArray withCurrentBitrate:SlikeMediaBitrateAuto];
    NSData *streamData = [autoBitrate dataUsingEncoding:NSUTF8StringEncoding];
    [loadingRequest.dataRequest respondWithData:streamData];
    [loadingRequest finishLoading];
    
    return TRUE;
    
}

- (NSString *)streamRelativeUrl:(NSString *)urlString withBase:(NSString *)baseUrlString
{
    if ([urlString hasPrefix:@"http"] || [urlString hasPrefix:@"https"])
    {
        return urlString;
    }
    NSURL *url = [NSURL URLWithString:baseUrlString];
    url = [url URLByDeletingLastPathComponent];
    return  [[url URLByAppendingPathComponent:urlString] absoluteString];
}
- (BOOL)handleSegmentsRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
    NSURLRequest *redirect = nil;
    redirect = [NSURLRequest requestWithURL:[NSURL URLWithString:[[[(NSURLRequest *)[loadingRequest request] URL] absoluteString] stringByReplacingOccurrencesOfString:@"123" withString:@"https"]]];
    
    // NOTE: After several hours of digging I found that you CANNOT pass HLS chunks directly
    // to the player. It would be great *if* this was possible because after we download the file
    // we could save it to disk and pass it via respondWithData thus only using one network
    // call per chunk.
    
    if (redirect) {
        [loadingRequest setRedirect:redirect];
        NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:[redirect URL] statusCode:302 HTTPVersion:nil headerFields:nil];
        [loadingRequest setResponse:response];
        [loadingRequest finishLoading];
        
    } else {
        [loadingRequest finishLoadingWithError:[NSError errorWithDomain: NSURLErrorDomain code:400 userInfo: nil]];
    }
    
    return YES;
}
-(void) processMasterPlayListData:(NSString*)str
{
    NSCharacterSet *newlineCharSet = [NSCharacterSet newlineCharacterSet];
    NSArray *lines = [str componentsSeparatedByCharactersInSet:newlineCharSet];
    [lines enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSString *lineString = (NSString *)obj;
        if ([lineString hasPrefix:strXSTREAMINFSPL] && [lineString containsString:strXSTREAMINFSPL])
        {
            if(lineString && [lineString isKindOfClass:[NSString class]])
            {
                NSLog(@"lineString %@",lineString);
                if(self.baseURI && [self.baseURI isEqualToString:@""])
                {
                    if ([lineString containsString:@"BURL="])
                    {
                        self.baseURI = [[lineString componentsSeparatedByString:@"BURL="] lastObject];
                        self.baseURI  =   [self.baseURI stringByReplacingOccurrencesOfString:@"\"" withString:@""];
                    }
                }
            }
        }
    }];
}
- (void)getActualM3U8:(NSURL*)url withCompletion:(BOOL(^)(NSString * result))completionBlock
{
    //    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_async(self.serialQueueAssetLoader, ^{
        NSError *error = nil;
        SPLM3U8PlaylistModel *model = [[SPLM3U8PlaylistModel alloc] initWithURL: url error:&error];
        NSInteger segmentCount = model.mainMediaPl.segmentList.count;
        if(self.baseURI && [self.baseURI isEqualToString:@""])
        {
            [self processMasterPlayListData: model.masterPlaylist.originalText];
        }
        __block NSString * actualM3U8 = model.mainMediaPl.originalText;
        NSCharacterSet *newlineCharSet = [NSCharacterSet newlineCharacterSet];
        NSArray *lines = [actualM3U8 componentsSeparatedByCharactersInSet:newlineCharSet];
        [lines enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            NSString *lineString = (NSString *)obj;
            
            if ([lineString hasPrefix:TAG_KEYSPL] && [lineString containsString:@"keys.slike.in"]) {
                self.isEncrypted = YES;
                actualM3U8 = [actualM3U8 stringByReplacingOccurrencesOfString:lineString
                                                                   withString:@""];
                
            }
        }];
        
        if(!self.isEncrypted) {
            completionBlock(actualM3U8);
        }
        
        NSString *strBase = [[[model.mainMediaPl originalURL] absoluteURL] absoluteString];
        strBase = [strBase substringToIndex:[strBase rangeOfString:@"/" options:NSBackwardsSearch].location + 1];
        SlikeDLog(@"Main Playing Url %@",strBase);
        for(int i = 0 ; i<segmentCount ; i++)
        {
            SPLM3U8SegmentInfo * segmentInfo = [model.mainMediaPl.segmentList segmentInfoAtIndex:i];
            //SlikeDLog(@"%@",segmentInfo.URI);
            actualM3U8 = [actualM3U8 stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@"%@",segmentInfo.URI]
                                                               withString:[self getENS:[NSString stringWithFormat:@"%@",segmentInfo.URI] withBaseURI:strBase]];
        }
        
        self.mainPlayListmodel =  model;
        completionBlock(actualM3U8);
    });
}

-(NSString*) getENS:(NSString*)s withBaseURI:(NSString *) strBaseUri
{
    if(![s isKindOfClass:[NSString class]] && [s isEqualToString:@""])
    {
        return nil;
    }
    else
    {
        if(![strBaseUri isKindOfClass:[NSString class]] || strBaseUri == nil)
        {
            return nil;
        }
        NSString * host = @"";
        NSURL *hostUrl = [NSURL URLWithString:strBaseUri];
        host = [hostUrl host];
        NSArray * hostEntry = [self.baseURI componentsSeparatedByString:@","];
        if(self.isDecoded == -1)
        {
            for(NSString * str in hostEntry)
            {
                if([str containsString:host] || [host containsString:str])
                {
                    self.isDecoded =  1;
                    break;
                }
            }
        }
        // NSLog(@"isExist %ld",self.isDecoded);
        if(self.isDecoded == 1 || [self.baseURI isEqualToString:@""])
        {
            NSArray *array =  [s componentsSeparatedByString:@"_"];
            if(array.count>1)
            {
                NSString *mediaSeqStr =  [array objectAtIndex:1];
                mediaSeqStr = [mediaSeqStr stringByReplacingOccurrencesOfString:@".ts" withString:@""];
                NSInteger numMediaSeqStr =  [mediaSeqStr integerValue];
                int index = numMediaSeqStr % 100;
                NSString *salt = [self getValueFromList:index];
                NSString *combinedStr = [NSString stringWithFormat:@"%@%@%@",[array objectAtIndex:0],salt,[array objectAtIndex:1]];
                unsigned long result = [combinedStr crc32];
                NSString *actualTS = [NSString stringWithFormat:@"%@%lu_%@",strBaseUri == nil ? @"" : strBaseUri,result,[array objectAtIndex:1]];
//                actualTS = [actualTS stringByReplacingOccurrencesOfString:@"low" withString:@"high"];
                SlikeDLog(@"actualTS Encript %@",actualTS);
                return actualTS;
            }
        }else
        {
            NSString *actualTS = [NSString stringWithFormat:@"%@%@",strBaseUri == nil ? @"" : strBaseUri,s];
            SlikeDLog(@"actualTS Not  %@",actualTS);
            return actualTS;
        }
    }
    return @"";
}
-(NSString*)getValueFromList:(int)indx
{
    if(_splitArray.count > indx)
    {
        return [_splitArray objectAtIndex:indx];
    }else
    {
        return @"";
    }
}
-(NSArray*)splitArrayFromGlobalString:(NSString*)rawString
{
    int j = 0;
    NSMutableArray * subStringArray =  [NSMutableArray array];
    for (int i = 1; i < 101; i++) {
        [subStringArray addObject:[rawString substringWithRange:NSMakeRange(j,32)]];
        j = j + 32;
    }
    return subStringArray;
}
@end

