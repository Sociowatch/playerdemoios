//
//  SlikeAssetLoaderDelegate.m

#define globalSplitStringSecure     @"fmwrk4zonihq2udbx6ysa3e15pjlctgvuxmcrs4j2la3fvdy1nzwghei5b6qkptozhwyi2msprqgkvcbjn5o1tdexaf3ul64ofebrw6nlkxz2qmi3syjg14huadt5pvcfizapc5qx6s2g3y1rdkumhe4jtnbwvloqt324zhrmcpnewxvldayigs1jbokf65ugeinv4afsbzylhd2r36qju1xcko5pmtwyoqwg24vetnxfc1ijsma3up56lkdrbzhqwajrhfkpsteo3z2xycm6dngvu1l4i5b3u14h6csbinlo5fdetaxvpqzwyjkrgm2u5xbqg1awtm62ij4dsrfplkvnz3yechot2jxkw3qnur6deabs1c5pzfymo4vghilvxq2odmyrt3jh15l6su4aezwibncpfkghyeav2cig5jr3xolbkmtwsnu1d46qfzpjf26swxomvri13etdgu4yph5qbzacknlcntr5yduqbls4fxep13zohvmaiwkj2g6e23rivlzgwkomhycutdajb4xnp5fqs16gv4x5uawh1mdfyplciqtr3nb6zj2oeskzxphercb5idmufv2n3ytsg4lkajwo16q5dxcpl2fbujasvtwze1rgm36hoy4nqik4coqdthn2iwp6fal1jbygexrvm3uzsk5wcd5joeqmpbyk1uriagzftlx24hvs3n6okt3bhfuqi4nwx2yjmzd1asrplveg6c5qpgliv1btcnkzd5eoh24suxarmyj6wf3wage6smr51uzifyknvjlp2hodbqx4c3t5bqy1rne4fkgjzdvtopsc2x6awhu3ilmup1m5bsihd3kvwygor2zcxe4fa6tqnljo2ui61ehsl5crpbtqvf4wgyamxjkz3nd1eoxhrznmwua6qv4fpsyl3jbg2k5tdicwg3boymudrh2xqcfpi1vz4jnaklt65eshdpbti4oyal2zr5ve6fxk3nwcgmsqju11nlf4vkpgwutd6jrocb3qhexysai5zm2ywpju3calebz1hdfoqivm64ktrx5gn2sxq5yvzgdh6ncpm1bis43rowuetjfkla2gailh6kzsup34rbjqtfc12mvoynxdw5ehm5q2spwx6ckjno3da14zyeiugtlbvfrq1jumkalp24yscrdxgebn6vzit5f3howwtefzpgjsqcvlkih4d3amxy2ruo615bnnxeogw6fh25tk1pyc4virbldmu3asjqzkpq25xelusdi3myjzctw4r1bhnf6goavqklefjt2xzw4d1gu6b3rmanyi5hspcvozmtuj1rcvligq65nb3s4dopahky2efxwjzegryi4wsm21kuopdlt3na56hxqcfbvmw1fxbdj3nlk4ya2vq6rheicuz5potsgmuc612dxbznt5foieyrgap4klqh3vwjsm3pt16jygna2bhdezwci5vu4srofqxklfsumto5zid2al3njbkhwypvq1xge4r6c3l4qky1bmntxpd2cs5wgeifrjzah6vousmkfxcq6hvdbw45jpnytzieao2u13glr2i6cxobhnupyqsr5kzawl4dtegm1fvj3gdm1sfatp3hi42bjvowzckq5ruy6lxnedoir4qpfemhza6l1x2tbvg5snyucj3kwunk6qf1a53ybs2hriepjz4gwcdxvltomlrvqcpodgahmyjbzuwnf25tes146kx3irtlkcpxjbgyeso6iz4wqhmf12dv5aun3posrbm6fetdu12hkjyzwglxn4vacq53i4h2v1zqylcok3xmuns6rdtiw5ebpjfgac5o3qzlpvwkgu6xtjder4fmh1bs2inyabonvpld6a5isw4eq2fxryjkhzcm3gu1tt562ezahq3knoc4isvlxuyjmwbpr1gfdpibqx3n5mt24vdlrcuhyws6fgao1jkezonvxep1tyamdfjc54grzkswuqhi32b6lv1dtjxmrf2hs6pkzlbicuwyg5noaqe43uey3bnaimdswf2ozxrpgkc5vjhl64t1q5cd1rxo3msgtknuqvwjie462lbzafyph6tlb5uagwirhzvsc3njyk4mopedqx2f1ga5tz6nkj32ilcrvehmfqospb4y1duxwqr5dlpmucwtaivjyognkxhb1f34esz26gqno1puc34ysk6rtafdxlzejmw5hvb2iqernjwkgluf4dz3b1y2caoi6v5tmxspharmkhfu21ij3dvwnq6bsgetxy5o4pczl36rpxij5cf2a1hqbmoynugwtvd4elzskwi41qvsmpkaneothu6ydr23cbgxl5zfjbws3hxlqk1mn6jdpuvaiyf5geoct24zrnl3i6rge1kt4ypqaujhvfw5b2mcsoxdz236tih5lq4baduerpfgosxjn1kycvwzmsbrygopcwi1kevj6nlxz345mhdq2uatf5oqcp3tfwmyr2skj6lg4ebaz1duinvxhlza3gq4hwbucxrtpf1o6i5sekjdmynv21bm3npufjasrh52l4qycoegxzvk6itdw4qsdvlnc3pfkoi6jmeuwr2a1zbhy5xtgsdyl4mjfp6ez1irvngwua53qbtxok2chdyagksp2ul35wthzxcjnrfoq4bmv1e6iscnqjo5ai3bwe6fl4pvhd2grmuktzxy1ukpdhozlntrqixgys2wjbavc163emf454hpngq5ivlets2cxk3bu1ayozjrfwmd6srbpfa54udnwx1j3kte2glymqho6izvcjkydxis6nbz1uvp3ah2tcgm4folerqw5xu6zogdc1sbh5na3twlpk4f2mvryjeiqvs51kthxgf263mrbqzinaujwdec4yoplcahbvone61g24yjkrsipq5t3ufdmzlxw2b643mwi5pvlfnujq1gtzecdskyhaxrooeyubfkazcwimxls5nvjrpd4h23gt6q1b3vn1cqzmkdpaxfyut4joig56ls2hwerdbjiwth3nrv6lgaqpofsm2ux1k4ze5yc3kqhmbysjxli4ncu2of1pwzatd5rv6egfq3ltgybzn6hekxmwcrpo2avsd15uj4igzpwd3acej4rnso5itulm2vb16yhkfxqxu16r2gfyvkejhqpodinctwalbzs54m3rq13pcfn4meixuv5ldbtjsohgkyazw62"

#import "SlikeAssetLoaderDelegate.h"
#import "SlikeNetworkManager.h"
#import "SlikeSharedDataCache.h"
#import "SlikeBitratesModel.h"
#import "SlikeNetworkInterface.h"
#import "SPLM3U8ExtXMediaList.h"
#import "SLManifestlessDataCache.h"

NSString * const BANDWIDTH = @"BANDWIDTH";
NSString * const CODECS = @"CODECS";
NSString * const RESOLUTION = @"RESOLUTION";
NSString * const TAG_PLAYLIST = @"#EXTM3U";
NSString * const TAG_STREAM = @"#EXT-X-STREAM-INF:";
NSString * const TAG_KEYSPL = @"#EXT-X-KEY";
NSString * const TAG_STREAMINFSPL = @"#EXT-X-STREAM-INF:";
NSString * const TAG_MEDIA = @"#EXT-X-MEDIA";

@interface SlikeAssetLoaderDelegate() {
}
@property (assign) BOOL hadMediaTag;
@end

@implementation SlikeAssetLoaderDelegate {
    
}

- (id)init{
    if (self = [super init]) {
        
        self.baseURI = @"";
        self.serialQueueAssetLoader = dispatch_queue_create("com.slikeSPL.queueAssetLoader", DISPATCH_QUEUE_SERIAL);
        self.isDecoded = -1;
        _splitArray =  [self splitArrayFromGlobalString:globalSplitStringSecure];
        _hadMediaTag = NO;
        
        
    }
    return self;
}

#pragma mark - NSURLConnection delegate

//Slike Task-
#pragma resource handling----
- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest {
    NSString *url = loadingRequest.request.URL.absoluteString;
    
    if ([url hasPrefix:khlsStreamHttp]) {
        
        NSLog(@"MANIFESTLESS:: TS from cache");
        NSString *hasCachedStream = [[SLManifestlessDataCache sharedManifestCache]cachedStreamForUrl:url];
        if (hasCachedStream) {
            NSData *charlieSendData = [hasCachedStream dataUsingEncoding:NSUTF8StringEncoding];
            [loadingRequest.dataRequest respondWithData:charlieSendData];
            [loadingRequest finishLoading];
            return YES;
            
        }
        return [self handleSegmentsRequest:loadingRequest];
        
    } else {
        
        
        if([url containsString:@".ts"]) {
            return [self handleSegmentsRequest:loadingRequest];
        } else if(loadingRequest.dataRequest) {
            return [self handlePlaylistRequest:loadingRequest];
        }
    }
    return YES;
}

- (BOOL)handlePlaylistRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:loadingRequest.request.URL resolvingAgainstBaseURL:NO];
    //Is Secured
    if([urlComponents.scheme isEqualToString:@"slikehttps"]) {
        urlComponents.scheme = @"https";
    } else {
        urlComponents.scheme = @"http";
    }
    
    BOOL isAvailable = [[SlikeSharedDataCache sharedCacheManager] isBitratesAvailableForStream];
    NSMutableString *currentURL = [[SlikeSharedDataCache sharedCacheManager]currentStreamBitrateURL];
    
    if (isAvailable && currentURL) {
        NSData *charlieSendData = [currentURL dataUsingEncoding:NSUTF8StringEncoding];
        [loadingRequest.dataRequest respondWithData:charlieSendData];
        [loadingRequest finishLoading];
        return TRUE;
    }
    
    if(!self.isEncrypted) {
        
        NSError *error = nil;
        SPLM3U8PlaylistModel *model = [[SPLM3U8PlaylistModel alloc] initWithURL: [urlComponents URL] error:&error];
        
        if(self.baseURI && [self.baseURI isEqualToString:@""]) {
            [self processMasterPlayListData: model.masterPlaylist.originalText];
        }
        
        __block NSString * actualM3U8 = model.mainMediaPl.originalText;
        NSCharacterSet *newlineCharSet = [NSCharacterSet newlineCharacterSet];
        NSArray *lines = [actualM3U8 componentsSeparatedByCharactersInSet:newlineCharSet];
        [lines enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            NSString *lineString = (NSString *)obj;
            if ([lineString hasPrefix:TAG_KEYSPL] && [lineString containsString:@"keys.slike.in"]) {
                self.isEncrypted = YES;
                actualM3U8 = [actualM3U8 stringByReplacingOccurrencesOfString:lineString
                                                                   withString:@""];
            }
        }];
    }
    
    [SlikeSharedDataCache sharedCacheManager].isEncrypted = self.isEncrypted;
    
    if(self.isEncrypted) {
        [self getActualM3U8:[urlComponents URL] withCompletion:^(NSString *result) {
            NSData *charlieSendData = [result dataUsingEncoding:NSUTF8StringEncoding];
            [loadingRequest.dataRequest respondWithData:charlieSendData];
            [loadingRequest finishLoading];
            return YES;
        }];
        
    } else {
        
        ///Look for the Cached Manifest file
        NSString *manifestFile = [[SLManifestlessDataCache sharedManifestCache]cachedManifestForKey:[urlComponents string]];
        if (manifestFile && [manifestFile length]>0) {
            [self parsePlaylistString:manifestFile baseUrl:[urlComponents string] loading:loadingRequest];
            NSLog(@"MANIFESTLESS:: MASTER from cache");
            return YES;
        }
        
        [[SlikeNetworkInterface sharedNetworkInteface] getHLSStreamDataString:[urlComponents string] withCompletionBlock:^BOOL(NSArray *bitratesArray, NSString *responseString, NSError *error) {
                    
            if (error) {
                return NO;
            }
            [self parsePlaylistString:responseString baseUrl:[urlComponents string] loading:loadingRequest];
            return YES;
        }];
    }
    
    return YES;
}


- (BOOL)parsePlaylistString:(NSString *)hlsContent baseUrl:(NSString *)baseUrl loading:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    //No Bitrates available . So we need to create
    __block NSMutableString * lowBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    __block NSMutableString * mediumBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    __block NSMutableString * highBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    __block NSMutableString * autoBitrate = [[NSMutableString alloc] initWithString:TAG_PLAYLIST];
    
    _hadMediaTag = NO;
    NSMutableArray *bitratesModelArray = [[NSMutableArray alloc]init];
    
    [lowBitrate appendString:@"\n"];
    [mediumBitrate appendString:@"\n"];
    [highBitrate appendString:@"\n"];
    [autoBitrate appendString:@"\n"];
    
    NSArray *lines = [hlsContent componentsSeparatedByString:@"\n"];
    NSInteger lineIndex = 0;
    
    while (lineIndex < [lines count]) {
        
        NSString *line = [lines objectAtIndex:lineIndex];
        if ([line rangeOfString:TAG_STREAM].location == 0) {
            
            NSArray *params = [[line substringFromIndex:[TAG_STREAM length]] componentsSeparatedByString:@","];
            
            NSString *keyValueString = nil;
            long long bitrate = 0;
            long long height = 0;
            
            [autoBitrate appendString:[lines objectAtIndex:lineIndex]];
            [autoBitrate appendString:@"\n"];
            NSInteger autoIndex = lineIndex;
            ++autoIndex;
            NSString *autoStreamURL = [self streamRelativeUrl:[lines objectAtIndex:autoIndex] withBase:baseUrl];
            [autoBitrate appendFormat:@"%@\n", autoStreamURL];
            for (NSInteger itemIndex = 0; itemIndex < [params count]; itemIndex++) {
                
                keyValueString = [params objectAtIndex:itemIndex];
                if ([keyValueString rangeOfString:@"BANDWIDTH"].location != NSNotFound) {
                    bitrate = [[[keyValueString componentsSeparatedByString:@"="] objectAtIndex:1] longLongValue];
                }
                else if ([keyValueString rangeOfString:@"RESOLUTION"].location != NSNotFound) {
                    NSString *heightSting = [[keyValueString componentsSeparatedByString:@"="] objectAtIndex:1];
                    height = [[[heightSting componentsSeparatedByString:@"x"] objectAtIndex:1] longLongValue];
                }
            }
            
            bitrate = bitrate/1000;
            if (height < 360 || bitrate < 450) {
                
                [lowBitrate appendFormat:@"%@\n", [lines objectAtIndex:lineIndex]];
                lineIndex++;
                NSString *streamURL = [self streamRelativeUrl:[lines objectAtIndex:lineIndex] withBase:baseUrl];
                [lowBitrate appendFormat:@"%@\n", streamURL];
                
            } else if ((height <= 480 && height >= 360) ||
                       (bitrate <= 800 && bitrate >= 450)) {
                
                [mediumBitrate appendFormat:@"%@\n", [lines objectAtIndex:lineIndex]];
                lineIndex++;
                NSString *streamURL = [self streamRelativeUrl:[lines objectAtIndex:lineIndex] withBase:baseUrl];
                [mediumBitrate appendFormat:@"%@\n", streamURL];
                
            }
            else if (height > 480 || bitrate > 800) {
                [highBitrate appendFormat:@"%@\n", [lines objectAtIndex:lineIndex]];
                lineIndex++;
                NSString *streamURL = [self streamRelativeUrl:[lines objectAtIndex:lineIndex] withBase:baseUrl];
                [highBitrate appendFormat:@"%@\n", streamURL];
            }
        } else if ([line hasPrefix:TAG_MEDIA] && [line rangeOfString:TAG_MEDIA].location == 0) {
            _hadMediaTag = YES;
        }
        lineIndex++;
    }
    
    NSInteger validationCons = 5;
    //Parse the Media List
    NSError *error = nil;
    SPLM3U8PlaylistModel *model = [[SPLM3U8PlaylistModel alloc] initWithString:hlsContent baseURL:[NSURL URLWithString:baseUrl] error:&error];
    
    if (model && !error && [model.masterPlaylist.xMediaList.subtitleList count]>0 && _hadMediaTag) {
        
        NSString *mediaListString = [model.masterPlaylist m3u8MediaListPlanString];
        if ([lowBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
            [lowBitrate appendString:mediaListString];
        }
        
        if ([mediumBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
            [mediumBitrate appendString:mediaListString];
        }
        
        if ([highBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
            [highBitrate appendString:mediaListString];
        }
        
        if ([autoBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
            [autoBitrate appendString:mediaListString];
        }
        
        if (self.subtitleBlock) {
            _subtitleBlock(1);
        }
        
    } else {
        if (self.subtitleBlock) {
            _subtitleBlock(0);
        }
    }
    
    if ([autoBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* autoBitrateModel =  [[SlikeBitratesModel alloc]init];
        autoBitrateModel.bitrateName = [SlikePlayerSettings playerSettingsInstance].slikestrings.autoBitrateTitle;
        autoBitrateModel.bitrateUrl = autoBitrate;
        autoBitrateModel.isValid = YES;
        autoBitrateModel.bitrateType = SlikeMediaBitrateAuto;
        [bitratesModelArray addObject:autoBitrateModel];
    }
    
    if ([lowBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* lowBitrateModel =  [[SlikeBitratesModel alloc]init];
        lowBitrateModel.bitrateName = [SlikePlayerSettings playerSettingsInstance].slikestrings.lowBitrateTitle;
        lowBitrateModel.bitrateUrl = lowBitrate;
        lowBitrateModel.isValid = YES;
        lowBitrateModel.bitrateType = SlikeMediaBitrateLow;
        [bitratesModelArray addObject:lowBitrateModel];
    }
    
    if ([mediumBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* mediumBitrateModel =  [[SlikeBitratesModel alloc]init];
        mediumBitrateModel.bitrateName = [SlikePlayerSettings playerSettingsInstance].slikestrings.mediumBitrateTitle;
        mediumBitrateModel.bitrateUrl = mediumBitrate;
        mediumBitrateModel.isValid = YES;
        mediumBitrateModel.bitrateType = SlikeMediaBitrateMedium;
        [bitratesModelArray addObject:mediumBitrateModel];
    }
    
    if ([highBitrate length] > [TAG_PLAYLIST length]+ validationCons) {
        SlikeBitratesModel* highBitrateModel =  [[SlikeBitratesModel alloc]init];
        highBitrateModel.bitrateName = [SlikePlayerSettings playerSettingsInstance].slikestrings.highBitrateTitle;
        highBitrateModel.bitrateUrl = highBitrate;
        highBitrateModel.isValid = YES;
        highBitrateModel.bitrateType = SlikeMediaBitrateHigh;
        [bitratesModelArray addObject:highBitrateModel];
    }
    
    [[SlikeSharedDataCache sharedCacheManager]cacheBitratesModel:bitratesModelArray withCurrentBitrate:SlikeMediaBitrateAuto];
    NSData *streamData = [autoBitrate dataUsingEncoding:NSUTF8StringEncoding];
    NSLog(@"%@", autoBitrate);
    [loadingRequest.dataRequest respondWithData:streamData];
    [loadingRequest finishLoading];
    return TRUE;
    
}

- (NSString *)streamRelativeUrl:(NSString *)aStreamUrlString withBase:(NSString *)aMasterUrlString {
    
    if ([aStreamUrlString hasPrefix:@"http"] || [aStreamUrlString hasPrefix:@"https"]) {
        ///Look for the Cached Manifest file
        NSString *hasCachedStream = [[SLManifestlessDataCache sharedManifestCache]cachedStreamForUrl:aStreamUrlString];
        if (hasCachedStream) {
            return [self formatPrefix:aStreamUrlString];
        }
        return aStreamUrlString;
    }
    
    NSURL *url = [NSURL URLWithString:aMasterUrlString];
    url = [url URLByDeletingLastPathComponent];
    NSString *streamUrlString = [[url URLByAppendingPathComponent:aStreamUrlString] absoluteString];
    
    ///Look for the Cached Manifest file
    NSString *hasCachedStream = [[SLManifestlessDataCache sharedManifestCache]cachedStreamForUrl:streamUrlString];
    if (hasCachedStream) {
        return [self formatPrefix:streamUrlString];
    }
    return streamUrlString;
}

- (NSString *)formatPrefix:(NSString *)urlString {
    NSRange tldr = [urlString rangeOfString:@"://"];
    if (![urlString hasPrefix:@"//"] && tldr.location != NSNotFound) {
        urlString = [urlString stringByReplacingCharactersInRange:NSMakeRange(0, tldr.location) withString:khlsStreamHttp];
    }
    return urlString;
}

- (BOOL)handleSegmentsRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
    
    NSURLRequest *redirect = nil;
    NSString *url = loadingRequest.request.URL.absoluteString;
    NSRange tldr = [url rangeOfString:@"//"];
    if (![url hasPrefix:@"http"] && tldr.location != NSNotFound) {
        url = [url stringByReplacingCharactersInRange:NSMakeRange(0, tldr.location) withString:@"https:"];
    }
    redirect = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
    
    // NOTE: After several hours of digging I found that you CANNOT pass HLS chunks directly
    // to the player. It would be great *if* this was possible because after we download the file
    // we could save it to disk and pass it via respondWithData thus only using one network
    // call per chunk.
    
    if (redirect) {
        [loadingRequest setRedirect:redirect];
        NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:[redirect URL] statusCode:302 HTTPVersion:nil headerFields:nil];
        [loadingRequest setResponse:response];
        [loadingRequest finishLoading];
        
    } else {
        [loadingRequest finishLoadingWithError:[NSError errorWithDomain: NSURLErrorDomain code:400 userInfo: nil]];
    }
    
    return YES;
}


- (void)processMasterPlayListData:(NSString*)str {
    
    NSCharacterSet *newlineCharSet = [NSCharacterSet newlineCharacterSet];
    NSArray *lines = [str componentsSeparatedByCharactersInSet:newlineCharSet];
    [lines enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSString *lineString = (NSString *)obj;
        if ([lineString hasPrefix:TAG_STREAMINFSPL] && [lineString containsString:TAG_STREAMINFSPL])
        {
            if(lineString && [lineString isKindOfClass:[NSString class]])
            {
                if(self.baseURI && [self.baseURI isEqualToString:@""])
                {
                    if ([lineString containsString:@"BURL="])
                    {
                        self.baseURI = [[lineString componentsSeparatedByString:@"BURL="] lastObject];
                        self.baseURI  =   [self.baseURI stringByReplacingOccurrencesOfString:@"\"" withString:@""];
                    }
                }
            }
        }
    }];
}

- (void)getActualM3U8:(NSURL*)url withCompletion:(BOOL(^)(NSString * result))completionBlock {
    
    //    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_async(self.serialQueueAssetLoader, ^{
        NSError *error = nil;
        SPLM3U8PlaylistModel *model = [[SPLM3U8PlaylistModel alloc] initWithURL: url error:&error];
        NSInteger segmentCount = model.mainMediaPl.segmentList.count;
        if(self.baseURI && [self.baseURI isEqualToString:@""])
        {
            [self processMasterPlayListData: model.masterPlaylist.originalText];
        }
        __block NSString * actualM3U8 = model.mainMediaPl.originalText;
        NSCharacterSet *newlineCharSet = [NSCharacterSet newlineCharacterSet];
        NSArray *lines = [actualM3U8 componentsSeparatedByCharactersInSet:newlineCharSet];
        [lines enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            NSString *lineString = (NSString *)obj;
            
            if ([lineString hasPrefix:TAG_KEYSPL] && [lineString containsString:@"keys.slike.in"]) {
                self.isEncrypted = YES;
                actualM3U8 = [actualM3U8 stringByReplacingOccurrencesOfString:lineString
                                                                   withString:@""];
                
            }
        }];
        
        if(!self.isEncrypted) {
            completionBlock(actualM3U8);
        }
        
        NSString *strBase = [[[model.mainMediaPl originalURL] absoluteURL] absoluteString];
        strBase = [strBase substringToIndex:[strBase rangeOfString:@"/" options:NSBackwardsSearch].location + 1];
        SlikeDLog(@"Main Playing Url %@",strBase);
        for(int i = 0 ; i<segmentCount ; i++)
        {
            SPLM3U8SegmentInfo * segmentInfo = [model.mainMediaPl.segmentList segmentInfoAtIndex:i];
            //SlikeDLog(@"%@",segmentInfo.URI);
            actualM3U8 = [actualM3U8 stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@"%@",segmentInfo.URI]
                                                               withString:[self getENS:[NSString stringWithFormat:@"%@",segmentInfo.URI] withBaseURI:strBase]];
        }
        
        self.mainPlayListmodel =  model;
        completionBlock(actualM3U8);
    });
}

- (NSString*)getENS:(NSString*)s withBaseURI:(NSString *)strBaseUri {
    if(![s isKindOfClass:[NSString class]] && [s isEqualToString:@""]) {
        return nil;
        
    } else {
        
        if(![strBaseUri isKindOfClass:[NSString class]] || strBaseUri == nil) {
            return nil;
        }
        
        NSString * host = @"";
        NSURL *hostUrl = [NSURL URLWithString:strBaseUri];
        host = [hostUrl host];
        NSArray * hostEntry = [self.baseURI componentsSeparatedByString:@","];
        
        if(self.isDecoded == -1) {
            
            for(NSString * str in hostEntry) {
                
                if([str containsString:host] || [host containsString:str]) {
                    self.isDecoded =  1;
                    break;
                }
            }
        }
        
        if(self.isDecoded == 1 || [self.baseURI isEqualToString:@""]) {
            NSArray *array =  [s componentsSeparatedByString:@"_"];
            
            if(array.count>1) {
                NSString *mediaSeqStr =  [array objectAtIndex:1];
                mediaSeqStr = [mediaSeqStr stringByReplacingOccurrencesOfString:@".ts" withString:@""];
                NSInteger numMediaSeqStr =  [mediaSeqStr integerValue];
                int index = numMediaSeqStr % 100;
                NSString *salt = [self getValueFromList:index];
                NSString *combinedStr = [NSString stringWithFormat:@"%@%@%@",[array objectAtIndex:0],salt,[array objectAtIndex:1]];
                unsigned long result = [combinedStr crc32];
                NSString *actualTS = [NSString stringWithFormat:@"%@%lu_%@",strBaseUri == nil ? @"" : strBaseUri,result,[array objectAtIndex:1]];
                //                actualTS = [actualTS stringByReplacingOccurrencesOfString:@"low" withString:@"high"];
                SlikeDLog(@"actualTS Encript %@",actualTS);
                return actualTS;
            }
            
        } else {
            NSString *actualTS = [NSString stringWithFormat:@"%@%@",strBaseUri == nil ? @"" : strBaseUri,s];
            SlikeDLog(@"actualTS Not  %@",actualTS);
            return actualTS;
        }
    }
    
    return @"";
}

- (NSString*)getValueFromList:(int)aIndex {
    if(_splitArray.count > aIndex) {
        return [_splitArray objectAtIndex:aIndex];
    } else {
        return @"";
    }
}

- (NSArray*)splitArrayFromGlobalString:(NSString*)aRawString {
    int j = 0;
    NSMutableArray * subStringArray =  [NSMutableArray array];
    for (int i = 1; i < 101; i++) {
        [subStringArray addObject:[aRawString substringWithRange:NSMakeRange(j,32)]];
        j = j + 32;
    }
    return subStringArray;
}

@end

